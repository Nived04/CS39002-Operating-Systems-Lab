## Overview: 
Creating multiple processes using C and exploring ways to make them communicate with each other.

### fork():
A separate execution line (child process) is made that executes alongside the main (parent) process.
Return value: -1 for errors, 0 to the new process, and process ID of the new process to the old process.

*Use of fflush(stdout)*: 

The child and the parent processes print text so fast to the std output that the buffer actually collects 
all the text and displays it together. To prevent this from happening and letting printf print exactly when it
is called, it is important to use fflush(stdout), because it will clear the buffer every time

### wait():
A function that tells a process to stop execution until one of its child processes exits.
Return value: (pid_t)-1 for errors, or the pid of the child process.
- Case 1: Multiple child process, single wait call -> arbitrary child PID returned.
- Case 2: No child processes, returns -1 (doesn't block execution)

### Semaphores:
In linux, all semaphores are counting semaphores.
Syscalls:
- ***semget(key, nsems, flags)***:  
    \> key can be IPC\_PRIVATE or generated by ftok (similar to shmget), flag can be 0666|IPC\_CREAT|IPC\_EXCL...  
    \> returns the semaphore set identifier (semid) (or -1 on error)  
    \> **Not atomic calls** (at least not in the linux implementation);  
  
- ***semctl(semid, semnum, cmd, ...)***:  
    \> has 3 or 4 args, the 4th argument is optional, having the type: union semun  
    ```
    union semun {  
        int val;  
        struct semid_ds *buf;  
        unsigned short *array;  
        struct seminfo *__buf;  
    };  
    ```
    \> cmd can be IPC\_RMID, SETVAL, GETVAL
  
- ***semop(semid, ops, nops)***:  
    \> ops is of type (struct sembuf *)  
    ```
    struct sembuf {  
        unsigned short sem_num;  
        short sem_op;   (if +ve, increment value of semaphore by that value, if -ve, same as wait until abs(val)  
                        number of resources are available (:?), if 0, call blocked until semaphore value comes 0)
        short sem_flg;  
    };  
    ```
    \> **Atomic**  
    \> `semop()` is never automatically restarted after being interrupted  by  a  
       signal handler, regardless of the setting of the SA_RESTART flag when  
       establishing a signal handler

### Shared Memory:
Functions:
- ***shmget(key, size, flags)***:  
    \> key can be IPC\_PRIVATE or generated by ftok (similar to semget), flag can be 0666|IPC\_CREAT|IPC\_EXCL  
    \> returns the shared memory segment identifier (shmid) (or -1 on error)  
    \> **IPC\_EXCL**: used with IPC\_CREAT to ensure that the call fails if the segment already exists. errno is set to **EEXIST**

### Threads: 
Functions signatures:
- ***pthread\_create(pthread\_t \*thread, const pthread\_attr\_t \*attr, void \*(\*start\_routine)(void \*), void \*arg)***:  
- ***pthread\_join(pthread\_t thread, void \*\*retval)***:
- ***pthread\_exit(void \*retval)***:
- ***pthread\_cancel(pthread\_t thread)***:
- ***pthread\_mutex\_init(pthread\_mutex\_t \*mutex, const pthread\_mutexattr\_t \*attr)***:
- ***pthread\_mutex\_lock(pthread\_mutex\_t \*mutex)***:
- ***pthread\_mutex\_unlock(pthread\_mutex\_t \*mutex)***:
- ***pthread\_cond\_init(pthread\_cond\_t \*cond, const pthread\_condattr\_t \*attr)***:
- ***pthread\_cond\_wait(pthread\_cond\_t \*cond, pthread\_mutex\_t \*mutex)***:
- ***pthread\_cond\_signal(pthread\_cond\_t \*cond)***:
- ***pthread\_cond\_broadcast(pthread\_cond\_t \*cond)***:
- ***pthread\_cond\_destroy(pthread\_cond\_t \*cond)***:
