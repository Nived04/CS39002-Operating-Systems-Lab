## Overview: 
Creating multiple processes using C and exploring ways to make them communicate with each other.

### fork(): 
A separate execution line (child process) is made that executes alongside the main (parent) process.
Return value: -1 for errors, 0 to the new process, and process ID of the new process to the old process.

*Use of fflush(stdout)*:
```
The child and the parent processes print text so fast to the std output that the buffer actually collects 
all the text and displays it together. To prevent this from happening and letting printf print exactly when it
is called, it is important to use fflush(stdout), because it will clear the buffer every time
```

### wait():
A function that tells a process to stop execution until one of its child processes exits.
Return value: (pid_t)-1 for errors, or the pid of the child process.
- Case 1: Multiple child process, single wait call -> arbitrary child PID returned.
- Case 2: No child processes, returns -1 (doesn't block execution)

### Semaphores:
In linux, all semaphores are counting semaphores.
Syscalls:
- *semget(key, nsems, flags)*:  
    \> key can be IPC\_PRIVATE or generated by ftok (similar to shmget), flag can be 0666|IPC\_CREAT|IPC\_EXCL...  
    \> returns the semaphore set identifier (semid) (or -1 on error)  
    \> **Not atomic calls** (at least not in the linux implementation);  
- *semctl(semid, semnum, cmd, ...)*:  
    \> has 3 or 4 args, the 4th argument is optional, having the type: union semun  
    ```
    union semun {  
        int val;  
        struct semid_ds *buf;  
        unsigned short *array;  
        struct seminfo *__buf;  
    };  
    ```
    \> cmd can be IPC\_RMID, SETVAL, GETVAL 
- semop
    \> **Atomic**
